\nonstopmode{}
\documentclass[letterpaper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8,latin1]{inputenc}
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `pwn'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\item[Type]\AsIs{Package}
\item[Title]\AsIs{Get a grip on your data.}
\item[Version]\AsIs{0.1.5}
\item[Date]\AsIs{2017-12-28}
\item[Author]\AsIs{hellhound}
\item[Maintainer]\AsIs{hellhound }\email{hellhound007@gmail.com}\AsIs{}
\item[Description]\AsIs{A collection of functions used to clean data or just get to know a dataset better.}
\item[License]\AsIs{GPL-3}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{pwn-package}{Own your data.}{pwn.Rdash.package}
\aliasA{pwn}{pwn-package}{pwn}
\keyword{data}{pwn-package}
%
\begin{Description}\relax
A collection of utility functions for data cleaning, and just getting to know the data better. 
\end{Description}
%
\begin{Details}\relax

\Tabular{ll}{
Package: & pwn\\{}
Type: & Package\\{}
Version: & 0.1.5\\{}
Date: & 2015-12-16\\{}
License: & GPLv3\\{}
}
This package is meant to provide a collection of tools to reduce the general agony of data cleaning. 
Everytime you need to work with data from more than one source (or even then), you'll probably have to do it. 
Most of the functions here are meant to be applied directly to your data, and merely require you to supply the name of the dataframe(s) and/or variable in question. 
Functions that were meant to be applied to a vector will require the name of the vector, specified as a string. 
\end{Details}
%
\begin{Author}\relax
hellhound
Maintainer: hellhound <hellhound007@gmail.com>
\end{Author}
%
\begin{References}\relax
no references here. 
\end{References}
%
\begin{SeeAlso}\relax
Nothing to see here. 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# refer to help file for specific functions. 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{chkmate}{Cross check data.  }{chkmate}
\keyword{data}{chkmate}
\keyword{cross}{chkmate}
\keyword{check}{chkmate}
%
\begin{Description}\relax

A relatively(?) less painful way of comparing what you once believed to be identical variables in 2 different data sets. 
Specify how your data identifier, the variable in question and the acceptable difference threshold.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
chkmate(id1, var1, id2, var2, threshold)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{id1}] 

The (usually) case identifier for the first data set. 

\item[\code{var1}] 

The variable in question from the first data set. 

\item[\code{id2}] 

The case identifier in the second data set. 

\item[\code{var2}] 

The variable in question from the second data set. 

\item[\code{threshold}] 

A value between 0-1, indicating the acceptable difference threshold. I wouldn't recommend going higher than 10

\end{ldescription}
\end{Arguments}
%
\begin{Value}
Returns a dataframe contain the id and values which violate the specified difference threshold.
\end{Value}
%
\begin{Author}\relax
hellhound
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
id <- c(1:5)
alpha <- c(0.015, 0.35, 0.0025, 0.007, 0.125)

df0 <- data.frame(id,alpha)
df1 <- data.frame(id,alpha)
df1$alpha[2] <- 0.385# let's just increase this value by 10%
df1$alpha[5] <- NA

chkmate(df0$id,df0$alpha,df1$id,df1$alpha,0.05)
chkmate(df0$id,df0$alpha,df1$id,df1$alpha,0.1)

## The function is currently defined as
function (id1, var1, id2, var2, threshold) 
{
    df1 <- data.frame(id1, var1)
    df2 <- data.frame(id2, var2)
    dfx <- merge(df1, df2, by.x = "id1", by.y = "id2", all = T)
    colnames(dfx) <- c("id", "data1", "data2")
    accept.diff <- (dfx[, 2] + dfx[, 3])/2 * threshold
    dfx$chk <- ifelse(abs(dfx[, 2] - dfx[, 3]) > accept.diff, 
        1, 0)
    flag <- subset(dfx, chk == "1")
    return(flag)
  }
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{colmatch}{Identify overlapping columns in 2 dataframes. }{colmatch}
\keyword{compare}{colmatch}
\keyword{match}{colmatch}
\keyword{column}{colmatch}
%
\begin{Description}\relax
This function is meant to flag overlapping columns in 2 dataframes. Helps weed out duplicate variables when merging data. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
colmatch(red, blue)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{red}] 
is a dataframe.

\item[\code{blue}] 
is a dataframe.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
Displays the names of overlapping columns. 
\end{Value}
%
\begin{Author}\relax
hellhound
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
alpha <- c(1:5)
bravo <- c(6:10) 
charlie <- c(11:15)
delta <- c(16:20)
echo <- c(21:25)

df1 <- data.frame(alpha,bravo,charlie,delta)
df1a <- data.frame(alpha,bravo,delta)
df2 <- data.frame(alpha,bravo,delta,echo)

colmatch(df1,df1a)
colmatch(df2,df1)

## The function is currently defined as
function (red, blue) 
{
    redNmes <- names(red)
    blueNmes <- names(blue)
    RED <- data.frame(redNmes %in% blueNmes)
    RED$redNmes <- redNmes
    red1 <- subset(RED, RED$redNmes..in..blueNmes == "TRUE", 
        drop = T)
    x <- red1$redNmes
    cat("The following columns are common to both datasets:\n", 
        x, "\n")
  }
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{colpatch}{Column Patch}{colpatch}
\keyword{column}{colpatch}
\keyword{patch}{colpatch}
%
\begin{Description}\relax
colpatch takes 2 dataframes and fills in whatever columns are missing. If rbind isn't working and it says your dataframes have the same number of columns, run colchk to see what's different.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
colpatch(red, blue)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{red}] 
is a dataframe. 

\item[\code{blue}] 
is a dataframe.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
Returns a single datafame that is really a rbind of the 2, with missing columns patched, where necessary. 
If the columns are identical, it does a simple rbind and returns the result. Columns will be arranged with reference to the first dataframe in the input. 
\end{Value}
%
\begin{Author}\relax
hellhound
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
alpha <- c(1:5)
bravo <- c(6:10) 
charlie <- c(11:15)
delta <- c(16:20)
echo <- c(21:25)

df1 <- data.frame(alpha,bravo,charlie,delta)
df1a <- data.frame(alpha,bravo,delta)
df2 <- data.frame(alpha,bravo,charlie,echo)

dfx <- colpatch(df1,df1a)
head(dfx)

dfy <- colpatch(df1,df2)
head(dfy)

## The function is currently defined as
function (red, blue) 
{
    blue_lacks <- names(red) %in% names(blue)
    red_lacks <- names(blue) %in% names(red)
    if (all(blue_lacks == T) & all(red_lacks == T)) {
				cat("Column names are identical.\n No columns will be added for either dataframe. \n")
        out <- rbind(red, blue)
        return(out)
    }
    else if (!all(blue_lacks == T) & !all(red_lacks == T)) {
        not_in_blue <- names(red) %in% names(blue)
        redN <- names(red)
        blue_mia <- data.frame(redN, not_in_blue)
        blue_mia <- subset(blue_mia, blue_mia[, 2] == F)
        blue_mia <- blue_mia[, 1]
        blue_r <- length(blue[, 1])
        Nblue_mia <- length(blue_mia)
        not_in_red <- names(blue) %in% names(red)
        blueN <- names(blue)
        red_mia <- data.frame(blueN, not_in_red)
        red_mia <- subset(red_mia, red_mia[, 2] == F)
        red_mia <- red_mia[, 1]
        red_r <- length(red[, 1])
        Nred_mia <- length(red_mia)
        Blue_needs <- data.frame(matrix(NA, nrow = blue_r, ncol = Nblue_mia))
        colnames(Blue_needs) <- blue_mia
        blue <- cbind(blue, Blue_needs)
        Red_needs <- data.frame(matrix(NA, nrow = red_r, ncol = Nred_mia))
        colnames(Red_needs) <- red_mia
        red <- cbind(red, Red_needs)
        out <- rbind(red, blue)
        return(out)
    }
    else if (!all(blue_lacks == T) & all(red_lacks == T)) {
        not_in_blue <- names(red) %in% names(blue)
        redN <- names(red)
        blue_mia <- data.frame(redN, not_in_blue)
        blue_mia <- subset(blue_mia, blue_mia[, 2] == F)
        blue_mia <- blue_mia[, 1]
        blue_r <- length(blue[, 1])
        Nblue_mia <- length(blue_mia)
        Blue_needs <- data.frame(matrix(NA, nrow = blue_r, ncol = Nblue_mia))
        colnames(Blue_needs) <- blue_mia
        blue <- cbind(blue, Blue_needs)
        out <- rbind(red, blue)
        return(out)
    }
    else if (all(blue_lacks == T) & !all(red_lacks == T)) {
        not_in_red <- names(blue) %in% names(red)
        blueN <- names(blue)
        red_mia <- data.frame(blueN, not_in_red)
        red_mia <- subset(red_mia, red_mia[, 2] == F)
        red_mia <- red_mia[, 1]
        red_r <- length(red[, 1])
        Nred_mia <- length(red_mia)
        Red_needs <- data.frame(matrix(NA, nrow = red_r, ncol = Nred_mia))
        colnames(Red_needs) <- red_mia
        red <- cbind(red, Red_needs)
        out <- rbind(red, blue)
        return(out)
    }
  }
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{dlprime}{Primes those annoying variables that have a detection limit and have been keyed in as such. }{dlprime}
\keyword{detection}{dlprime}
\keyword{limit}{dlprime}
%
\begin{Description}\relax

This is a slightly more advanced version of dlsplit. 
dlprime will return the dataframe with the target variable as a numeric vector, and a second variable, taking the name "var\_detect", which will have one of 3 values: 2,1, 0 and -1. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dlprime(df1, varX)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df1}] 

is a dataframe with the variable in question. 

\item[\code{varX}] 

is column name of the variable in question, entered as a character string. 

\end{ldescription}
\end{Arguments}
%
\begin{Value}




dlprime will return the dataframe with the target variable as a numeric vector, and a second variable, taking the name "var\_detect", which will have one of 3 values: 1, 0 and -1. 
2 indicates a value above the highest reliable detection limit. 
1 indicates an actual value.
0 indicates a value that's below the detection limit.
-1 indicates an actual value, but is below the worst detection limit in the data entered. 
All of which will be tacked to the back of the dataframe. 
\end{Value}
%
\begin{Author}\relax
hellhound
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

id <- c(1:5)
alpha <- c(0.015, "<0.003", 0.0025, 0.007, "<0.003")
bravo <- c(0.002, "<0.003", 0.007, 0.125, ">1")
x <- data.frame(id,alpha,bravo)

x <- dlprime(x,"alpha")
x <- dlprime(x,"bravo")

## The function is currently defined as
function (df1, varX) 
{
    red <- as.character(df1[, varX])
    varNme <- as.character(varX)
    varNme_less <- paste(varNme, "detect", sep = "_")
    red.1stChar <- substr(red, 1, 1)
    dl_lim <- ifelse(red.1stChar == "<", 0, 1)
    red <- as.numeric(sub("<", "", red))
    blue <- data.frame(red, dl_lim)
    x <- subset(blue, blue$dl_lim == 0, drop = T)
    dls <- max(x$red)
    blue$dl_lim <- ifelse(blue$red < dls & blue$dl_lim != 0, 
        -1, blue$dl_lim)
    red <- blue$red
    dl_lim <- blue$dl_lim
    df1[, varX] <- NULL
    df1$red <- red
    names(df1)[names(df1) == "red"] <- varNme
    df1$detect_lim <- dl_lim
    names(df1)[names(df1) == "detect_lim"] <- varNme_less
    return(df1)
	}
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{dlsplit}{Splits the "<" sign from those annoying variables that have a detection limit and have been keyed in as such.  }{dlsplit}
\keyword{detection}{dlsplit}
\keyword{limit}{dlsplit}
\keyword{split}{dlsplit}
\keyword{fix}{dlsplit}
%
\begin{Description}\relax

Cleans those unusable variables that have a detection limit, and were keyed in with the "<" sign. R will read such variables as a factor. 
This will return the variable in question as a numeric and another variable that consists solely of the "<" sign.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dlsplit(df1, varX)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df1}] 

is a dataframe with the variable in question. 

\item[\code{varX}] 

is column name of the variable in question, entered as a character string. 

\end{ldescription}
\end{Arguments}
%
\begin{Author}\relax
It is I, LeClerc!
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
id <- c(1:5)
alpha <- c(0.015, "<0.003", 0.0025, 0.007, "<0.003")
bravo <- c(0.002, "<0.003", 0.007, 0.125, ">0.5")
x <- data.frame(id,alpha,bravo)

x <- dlsplit(x,"alpha")
x <- dlsplit(x,"bravo")

## The function is currently defined as
function (df1, varX) 
{
		red <- as.character(df1[,varX])
		varNme <- as.character(varX)
		varNme_less <- paste(varNme,"ND",sep="_")
		red.1stChar <- substr(red,1,1)
		red.lessthan <- ifelse(red.1stChar=="<","<",
										ifelse(red.1stChar==">",">",NA))
		red <- sub("<","",red)# remove less than sign.
		red <- as.numeric(sub(">","",red))# remove more than sign. 
		df1[,varX] <- NULL
		df1$var.nd <- red.lessthan
		names(df1)[names(df1) == 'var.nd'] <- varNme_less
		df1$red <- red
		names(df1)[names(df1) == 'red'] <- varNme
		return(df1)
		}
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fillVec}{Fill in the blanks when people can't be bothered to. }{fillVec}
\keyword{\textbackslash{}textasciitilde{}kwd1}{fillVec}
\keyword{\textbackslash{}textasciitilde{}kwd2}{fillVec}
%
\begin{Description}\relax
This function is meant to fill in a vector of what would be repeated values but for the fact that the person who created the original table (usually in excel or something like that) didn't fill in. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fillVec(broken_list)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{broken\_list}] 
A vector of values with gaps you want to plug. 

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A filled-in vector. 
\end{Value}
%
\begin{Author}\relax
hellhound
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
a <- c("a",NA,"bravo",NA,NA,"charlie",NA,NA,NA)
fillVec(a)
## The function is currently defined as
function (broken_list) 
{
    curr <- c()
    a <- c()
    for (i in broken_list) {
        if (is.na(i)) {
            a <- c(a, curr)
        }
        else {
            curr <- i
            a <- c(a, curr)
        }
    }
    return(a)
  }
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{rec}{Recon the data. }{rec}
\keyword{\textbackslash{}textasciitilde{}kwd1}{rec}
\keyword{\textbackslash{}textasciitilde{}kwd2}{rec}
%
\begin{Description}\relax
Presents a summary of a dataframe. Results can be stored for later use. Now with the option of silencing the output, and simply returning a line stating the number of cases and parameters in the dataset. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
rec(df1, details = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df1}] 
is a dataframe. 

\item[\code{details}] 
boolean variable, value defaults to TRUE. If set to FALSE, will not return the table describing each of the parameters. 

\end{ldescription}
\end{Arguments}
%
\begin{Value}
Displays the number of variables and cases, then a tabular description of the variables. The table may be stored for later use. 
\end{Value}
%
\begin{Author}\relax
hellhound
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (df1, details = TRUE) 
{
    if (isTRUE(details)) {
        cases <- length(df1[, 1])
        paras <- length(df1)
        cat("Data has: ", cases, " cases and ", paras, "parameters. \n")
        varnames <- names(df1)
        n_NA <- colSums(is.na(df1))
        n_NA <- data.frame(n_NA)
        n_NA <- n_NA[, 1]
        varClass <- c()
        varMin <- c()
        varMn <- c()
        varMd <- c()
        varMax <- c()
        for (i in df1) {
            var_class <- class(i)
            varClass <- c(varClass, var_class)
            if (var_class == "numeric" | var_class == "integer") {
                var_min <- min(i, na.rm = T)
                varMin <- c(varMin, var_min)
                var_mn <- mean(i, na.rm = T)
                varMn <- c(varMn, var_mn)
                var_md <- median(i, na.rm = T)
                varMd <- c(varMd, var_md)
                var_max <- max(i, na.rm = T)
                varMax <- c(varMax, var_max)
            }
            else {
                varMin <- c(varMin, NA)
                varMn <- c(varMn, NA)
                varMd <- c(varMd, NA)
                varMax <- c(varMax, NA)
            }
        }
        dfx <- data.frame(varnames, varClass, n_NA, varMin, varMn, 
            varMd, varMax)
        colnames(dfx) <- c("Variable", "Class", "NAs", "Min", 
            "Mean", "Median", "Max")
        return(dfx)
    }
    else {
        cases <- length(df1[, 1])
        paras <- length(df1)
        cat("Data has: ", cases, " cases and ", paras, "parameters. \n")
    }
  }
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{recomp}{Recompile data from 2 data sets. }{recomp}
\keyword{data}{recomp}
\keyword{\textbackslash{}textasciitilde{}kwd2}{recomp}
%
\begin{Description}\relax

This function takes 2 data frames and compiles them into a single one. This has nothing to do with rbind or merge. Rather, it's for the unfortunate times where you realize that 2 data sets you believed to be the same weren't. 

\end{Description}
%
\begin{Usage}
\begin{verbatim}
recomp(red, blu)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{red}] 

red is a dataframe with a case identifying column "id". It is also the slightly favoured dataset, and has to be specified first. 

\item[\code{blu}] 

blu is a dataframe that was supposed to be the same as red, but contains data red doesn't. Like red, it should also contain a case identifying column called "id".

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax

For this function to work, both your dataframes need to have the exact same columns, arranged in the exact same order. They should also both have a column called "id", containing unique case identifiers. 
If you lack any of the above (identical columns and an "id" column), this function will fail. Also, be sure to check the output. 
\end{Details}
%
\begin{Value}





Returns a single dataframe, compiled from the 2 that you specified. 
\end{Value}
%
\begin{Author}\relax

hellhound
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
x1 <- c(1:5)
x2 <- c(6:10)
x3 <- c(11:15)
x4 <- c(16:20)
x5 <- c(21:25)

# what you thought you had 2 copies of
dfx <- data.frame(rbind(x1,x2,x3,x4,x5))
colnames(dfx) <- c("alpha","bravo","charlie","delta","echo")

dfx$id <- row.names(dfx)
print(dfx)

x4 <- c(47,48,49,NA,51)
dfA <- data.frame(rbind(x1,x2,x3,x4,x5))
colnames(dfA) <- c("alpha","bravo","charlie","delta","echo")
dfA$id <- row.names(dfA)
print(dfA)

# if there's missing cases 
x1 <- c(31:35)
dfz <- data.frame(rbind(x1,x3,x4,x5))
colnames(dfz) <- c("alpha","bravo","charlie","delta","echo")
dfz$id <- row.names(dfz)
print(dfz)
# say we favour dfz 
datadawg <- recomp(dfz,dfx)
print(datadawg)

## The function is currently defined as
function (red, blu) 
{
    f0 <- function(x, y) {
        a <- ifelse(!is.na(x), x, y)
        return(a)
    }
    n.red <- red[, "id"]
    n.blu <- blu[, "id"]
    purple <- unique(c(n.red, n.blu))
    df0 <- data.frame(purple)
    df0$red_missing <- !(purple %in% red$id)
    df0$blu_missing <- !(purple %in% blu$id)
    red_patch <- as.vector(df0[df0$red_missing == T, 1])
    blu_patch <- as.vector(df0[df0$blu_missing == T, 1])
    if (length(red_patch) > 0 & length(blu_patch) > 0) {
        red2 <- red[-c(1:length(red[, 1])), ]
        blank_row <- rep(NA, length(red2))
        for (i in c(1:length(red_patch))) {
            red2 <- rbind(red2, blank_row)
        }
        colnames(red2) <- names(red)
        red2$id <- red_patch
        red <- rbind(red, red2)
        red <- red[order(red$id), ]
        # print(red)
        blu2 <- blu[-c(1:length(blu[, 1])), ]
        blank_row <- rep(NA, length(blu2))
        for (i in c(1:length(blu_patch))) {
            blu2 <- rbind(blu2, blank_row)
        }
        colnames(blu2) <- names(blu)
        blu2$id <- blu_patch
        blu <- rbind(blu, blu2)
        blu <- blu[order(blu$id), ]
        # print(blu)
        dfx <- mapply(f0, red, blu)
    }
    else if (length(red_patch) == 0 & length(blu_patch) > 0) {
        blu2 <- blu[-c(1:length(blu[, 1])), ]
        blank_row <- rep(NA, length(blu2))
        for (i in c(1:length(blu_patch))) {
            blu2 <- rbind(blu2, blank_row)
        }
        colnames(blu2) <- names(blu)
        blu <- rbind(blu, blu2)
        blu <- blu[order(blu$id), ]
        dfx <- mapply(f0, red, blu)
    }
    else if (length(red_patch) > 0 & length(blu_patch) == 0) {
        red2 <- red[-c(1:length(red[, 1])), ]
        blank_row <- rep(NA, length(red2))
        for (i in c(1:length(red_patch))) {
            red2 <- rbind(red2, blank_row)
        }
        colnames(red2) <- names(red)
        red2$id <- red_patch
        red <- rbind(red, red2)
        red <- red[order(red$id), ]
        # print(red)
        dfx <- mapply(f0, red, blu)
    }
    else {
        dfx <- mapply(f0, red, blu)
    }
    return(dfx)
  }
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{xchk}{Compares 2 character vectors and returns what's different. May be used for either case ids or column names or whatever else you want to cross check. }{xchk}
\keyword{data}{xchk}
\keyword{\textbackslash{}textasciitilde{}kwd2}{xchk}
%
\begin{Description}\relax

Compares 2 vectors and returns the differences.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
xchk(red, blu)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{red}] 

is a vector. 

\item[\code{blu}] 

is a vector. 

\end{ldescription}
\end{Arguments}
%
\begin{Author}\relax

hellhound
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

a <- c("alpha","bravo","charlie","delta","echo")
b <- c("alpha","bravo","charlie","echo","foxtrot")

xchk(a,b)

# if checking cases: 
# xchk(df1$id,df2$id) # or whatever your dataframes and/or unique case identifiers are called.

# if checking columns: 
# xchk(names(df1),names(df2))

## The function is currently defined as
function (red, blu) 
{
    red <- as.character(red)
    blu <- as.character(blu)
    purple <- unique(c(red, blu))
    df0 <- data.frame(purple)
    df0$red_missing <- !(purple %in% red)
    df0$blu_missing <- !(purple %in% blu)
    red_patch <- as.vector(df0[df0$red_missing == T, 1])
    blu_patch <- as.vector(df0[df0$blu_missing == T, 1])
    if (length(red_patch) > 0 & length(blu_patch) > 0) {
        cat("Values missing in the FIRST vector:\n")
        for (i in red_patch) {
            cat(i, "\n")
        }
        cat("\nValues missing in the SECOND vector:\n")
        for (i in blu_patch) {
            cat(i, "\n")
        }
    }
    else if (length(red_patch) == 0 & length(blu_patch) > 0) {
        cat("NO values missing in the first vector.\n")
        cat("\nValues missing in the SECOND vector:\n")
        for (i in blu_patch) {
            cat(i, "\n")
        }
    }
    else if (length(red_patch) > 0 & length(blu_patch) == 0) {
        cat("Values missing in the FIRST vector:\n")
        for (i in red_patch) {
            cat(i, "\n")
        }
        cat("No values missing in the second vector.\n")
    }
    else {
        cat("Cases match.\n")
    }
  }
\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
